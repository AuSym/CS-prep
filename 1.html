<!DOCTYPE html>
<html>
<head>
    <meta name ="viewport" content="with=device-width", initial-scale="1.0">
    <title> project </title>
    <link rel="stylesheet" href="style.css">
                                           <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@200;300;400;600;700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1">
<style>
.collapsible {
  background-color: #777;
  color: white;
  cursor: pointer;
  padding: 18px;
  width: 100%;
  border: none;
  text-align: left;
  outline: none;
  font-size: 15px;
}

.active, .collapsible:hover {
  background-color: #555;
}

.content {
  padding: 0 18px;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.2s ease-out;
  background-color: #f1f1f1;
}
</style>
                                                                                                                        </head>
<body>
    <section class="none1">
        <nav>
            <div class="nav-links111">
              
                
                <ul> <li><a href="head%20page.html">HOME</a></li>
                    <li><a href="all-about.html"\>ABOUT</a></li>
                    <li><a href="terms.html">LESSONS</a></li>
                    <li><a href="">PRACTICE</a></li>
                    <li><a href="">TIPS</a></li>
                </ul>
            </div>
           
        </nav>
    </section>
<section class="term1">
  <h1 style="text-align: center; padding: 35px; font-size: 35px; color: black;">Term 1</h1>  
<button class="collapsible">11.3.1.1 justify the choice of application software and selection criteria for specific purposes              <br>11.3.1.2  classify application software </button>
<div class="content">
    <p><b>Application software</b> - software designed to help the user to perform specific tasks.<br>Types of application software:<br><b>1. General-Purpose Software</b>
<br>Definition: Software designed to perform a wide range of tasks and used by a broad range of users. It is not specialized for any particular industry or task but can be used in various environments.
<br>Example: Microsoft Office (Word, Excel, PowerPoint), Google Chrome (web browser), Adobe Acrobat (PDF reader).
<br><b>2. Bespoke (Custom) Software</b>
<br>Definition: Software that is custom-built for a specific organization or user to meet their particular needs. It is tailored to fit precise requirements, often not met by general-purpose software.
<br>Example: A custom-built inventory management system for a specific retail company, or a personalized CRM (Customer Relationship Management) system for a business.
<br><b>3. Specific-Purpose Software</b>
<br>Definition: Software designed for a particular purpose or task. It is specialized and typically used in specific industries or professions where general-purpose software is not adequate.
<br>Example: AutoCAD (for engineering and architecture), Sage (for accounting), Adobe Premiere Pro (for video editing).</p>
</div>
    
<button class="collapsible">11.3.1.3 describe the purpose and basic functions of operating systems <br>11.3.1.4 compare single-user and multi-user operating systems<br> 11.3.1.5 compare single-tasking and multitasking operating systems</button>
<div class="content">
    <p><b>Purpose of Operating Systems:</b>
<br><b>An operating system (OS)</b> is a software that acts as an intermediary between the user and the computer hardware. Its primary purpose is to manage and coordinate the use of the computer's resources, such as the processor, memory, and input/output devices, ensuring that all programs run efficiently. The OS also provides an environment for application software to execute and interact with the hardware.

<br><b>Basic Functions of Operating Systems: </b>
       <br> 1.Process Management:The OS manages the execution of programs, ensuring that each process gets adequate CPU time, multitasking when necessary, and handling the creation, scheduling, and termination of processes.

<br>2.Memory Management: It allocates and manages memory for running programs, ensuring that each program has sufficient memory space, while avoiding memory conflicts between applications.

<br>3.File System Management: The OS handles reading, writing, and managing files on storage devices (e.g., hard drives, SSDs). It organizes files into directories and provides permissions for access.

<br>4.Device Management: The OS manages communication with input/output devices (e.g., printers, monitors, keyboards) through device drivers, allowing seamless interaction between the hardware and applications.

<br>5.User Interface: The OS provides a user interface (either graphical or command-line) that allows users to interact with the computer and execute commands.

<br>6.Security and Access Control:It provides mechanisms to protect data and resources from unauthorized access through authentication and permissions.

<br><br><b>Single-User Operating System:</b>
<br>Definition: A single-user OS is designed to manage the computer for one user at a time. It focuses on tasks being performed by a single user, even if the system allows multiple tasks to run in the background.
<br>Examples: Windows 10, macOS.
<br>Use Case: Personal computers, laptops, and devices where only one user interacts with the system at a time.
<br><b>Multi-User Operating System:</b>
<br>Definition: A multi-user OS allows multiple users to access the computer’s resources simultaneously, either locally or remotely. It efficiently manages resources like memory and CPU to serve multiple users at the same time.
<br>Examples: UNIX, Linux (in server mode), Mainframe operating systems.
<br>Use Case: Server environments, mainframes, or networks where many users need to access shared resources concurrently.
    </p>

        <table>
  <thead>
    <tr>
      <th >Feature	 </th>
        <th >Single-User OS</th>
         <th >Multi-User OS</th>
     
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Users	</td>
     <td>	One user at a time</td>
         <td>	Multiple users simultaneously</td>
      
    </tr>
      <tr>
      <td>Resource Management		</td>
      <td>Simple, focused on one user’s tasks</td>
          <td>Complex, needs to allocate resources for multiple users</td>
    </tr>
      <tr>
      <td>Security		</td>
      <td>Security focused on a single user</td>
             <td>Stronger security and user management to prevent conflicts between users</td>
    </tr>
      <tr>
      <td>Use		</td>
      <td>Desktops, laptops</td>
             <td>Servers, networked environments	</td>
    </tr>
  </tbody>
</table>
    <p> <br><br><b>Single-Tasking Operating System:</b>
<br>Definition: A single-tasking OS allows the execution of only one task or application at a time. The system focuses solely on that task until it is completed, before starting a new one.
<br>Example: MS-DOS (Microsoft Disk Operating System).
<br>Use Case: Early computers, embedded systems, or devices where only one process needs to be managed.
<br><b>Multitasking Operating System:</b>
<br>Definition: A multitasking OS can handle multiple tasks at the same time. The OS switches between tasks efficiently, giving the illusion that several tasks are running simultaneously.
<br>Examples: Windows, Linux, macOS.
<br>Use Case: Modern computers and smartphones, where users expect to run several applications (like a web browser, media player, and text editor) at once.
    </p>

        <table>
  <thead>
    <tr>
      <th >Feature	 </th>
        <th >Single-Tasking OS	</th>
         <th >Multitasking OS</th>
     
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Task Management		</td>
     <td>		One task at a time</td>
         <td>	Multiple tasks concurrently</td>
      
    </tr>
      <tr>
      <td>Efficiency		</td>
      <td>Simple, less resource-intensive	</td>
          <td>	More complex, requires efficient resource management</td>
      <tr>
      <td>Use		</td>
      <td>Embedded systems, simple environments	</td>
             <td>Desktops, servers, modern devices	</td>
    </tr>
  </tbody>
</table>
</div>
    <button class="collapsible">11.3.2.1  describe the interaction of CPU with peripheral devices      <br>        11.3.2.2 describe the purpose of CPU components, system bus and main memory </button>
<div class="content">
    <p><b>11.3.2.1  describe the interaction of CPU with peripheral devices</b><br> <br><b>The CPU (Central Processing Unit)</b> interacts with peripheral devices through a process that involves the use of several components, including the system bus and I/O (input/output) controllers. Peripheral devices are hardware components that are not part of the core computer architecture but are used to input, output, or store data (e.g., keyboards, mice, printers, external hard drives).

      <br> <b> I/O Controllers:</b> Each peripheral device is connected to the CPU through an I/O controller, which acts as an intermediary between the CPU and the peripheral. The controller converts data from the format used by the peripheral to the format used by the system.
      <br> <b> System Bus:</b> The CPU communicates with peripherals via the system bus, which includes the data bus (for data transfer), the address bus (to specify the device's address), and the control bus (to manage signals and control operations).
      <br> <b> Interrupt Requests (IRQ):</b> Peripheral devices can send an interrupt signal to the CPU when they need attention (e.g., a mouse click or data from a printer). The CPU temporarily halts its current operations, processes the interrupt, and then resumes its previous task.
      <br> <b> DMA (Direct Memory Access): </b>For high-speed data transfers (e.g., between the hard drive and RAM), the CPU can delegate the task to a DMA controller, which allows peripherals to access memory directly, reducing CPU load.
      <br><br><b> 11.3.2.2 describe the purpose of CPU components, system bus and main memory</b>
      <br> <br><b> 1. CPU Components:</b>

 <br>  Control Unit (CU): The CU directs the operations of the CPU, interpreting program instructions and coordinating communication between the CPU and other components (such as memory and I/O devices).
 <br>  Arithmetic Logic Unit (ALU): The ALU performs arithmetic (addition, subtraction, etc.) and logical (AND, OR, NOT) operations. It processes the actual data that the CPU works on.
 <br>  Registers: These are small, fast storage areas in the CPU that temporarily hold data, instructions, and addresses. Registers such as the Program Counter (PC) and Accumulator are essential for the execution of programs.
 <br>  Cache Memory: The CPU cache is a small, high-speed memory that stores frequently accessed data to reduce the time it takes to retrieve it from main memory.
      <br> <b> 2. System Bus:</b>
The system bus is a set of electrical pathways used to transfer data, addresses, and control signals between the CPU, memory, and peripherals. It consists of three main types of buses:

 <br>  Data Bus: Transfers the actual data between the CPU, memory, and peripherals.
 <br>  Address Bus: Carries the addresses of data (in memory or I/O devices) that the CPU wants to access.
 <br>  Control Bus: Sends control signals (such as read or write commands) to coordinate operations between different parts of the system.
      <br> <b> 3. Main Memory (RAM):</b>
 <br>  Purpose: The main memory (RAM) stores data and instructions that are currently being used by the CPU. It is a volatile memory, meaning it only holds data when the computer is powered on.
 <br>  Interaction with the CPU: The CPU fetches instructions and data from the RAM during the fetch-decode-execute cycle. When the CPU processes an instruction, it reads or writes data to the memory. Since RAM is much faster than secondary storage (like a hard drive), it significantly speeds up the execution of programs. However, the CPU accesses data in RAM through the system bus.</p>
</div>
    
    <button class="collapsible">11.3.4.1 explain the differences between RAM and ROM <br>11.3.4.2 explain the purpose of virtual memory        <br>      11.3.4.3 explain the purpose of cache memory </button>
<div class="content">
    
    <p>
    <b>11.3.4.1 explain the differences between RAM and ROM </b> 
    </p>
    <table>
  <thead>
    <tr>
      <th >Feature	 </th>
        <th >RAM (Random Access Memory)</th>
         <th >ROM (Read-Only Memory)</th>
     
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Definition</td>
     <td>	This is a type of volatile memory used for temporarily storing data and instructions that the CPU needs while executing tasks. Data in RAM is lost when the power is turned off.</td>
         <td>	This is a type of non-volatile memory that contains permanently written data and instructions. ROM retains its contents even when the power is turned off.</td>
      
    </tr>
      <tr>
      <td> Purpose	</td>
      <td>Used for active processes and applications; it allows for read and write operations, enabling data to be accessed quickly by the CPU.</td>
          <td>Primarily used to store firmware and system software that are essential for booting the computer and performing basic hardware initialization.</td>
    </tr>
      <tr>
      <td>Volatility	</td>
      <td>Volatile, meaning it loses its data when the power is off.</td>
             <td>Non-volatile, retaining its data without power.</td>
    </tr>
      <tr>
      <td> Speed		</td>
      <td>Faster than ROM, providing quick access for running programs.</td>
             <td> Generally slower than RAM since it is used for storing static data.	</td>
    </tr>
  </tbody>
</table>
      <p> <b>11.3.4.2 explain the purpose of virtual memory  </b> 
   <br> <b> Virtual Memory </b>  is a memory management technique that uses a portion of the hard drive (or SSD) to simulate additional RAM. Its main<b> purposes</b> are:

 <br> <br> <b>Extending Usable Memory:</b> Virtual memory allows a system to run larger applications or multiple applications simultaneously, even if the physical RAM is limited. It gives the impression of having more RAM than is physically present.

 <br> <br> <b>Isolation and Protection:</b> Each process operates in its own virtual address space, which helps prevent one process from accessing the memory of another. This enhances security and stability in multi-tasking environments.

 <br> <br> <b>Efficient Memory Management: </b>The operating system can swap data between physical memory (RAM) and disk storage, optimizing the use of available memory resources. This process is called paging.

 <br>  <br><b>Handling Memory Overflow:</b> When the physical memory is full, the operating system can move less frequently used data to the virtual memory, freeing up RAM for active processes.   </p>
      <p>  <b> 11.3.4.3 explain the purpose of cache memory   </b> 
          <b> <br><br>   Cache Memory </b>is a small, high-speed storage area located within or close to the CPU. Its purposes include:

 <br>  <br><b>Speeding Up Data Access: </b>  Cache memory stores copies of frequently accessed data and instructions. By keeping this information close to the CPU, cache memory significantly reduces the time required to access data compared to fetching it from main memory (RAM).

 <br>  <br><b>Reducing Latency: </b>  Accessing data from cache is much faster than accessing it from RAM or disk storage, which helps improve overall system performance.

           <br>  <br><b>Improving CPU Efficiency: </b>  By providing quick access to data that the CPU is likely to use next, cache memory minimizes the number of times the CPU must wait for data to be fetched from slower storage, thus enhancing the efficiency of CPU operations. </p>
</div>
    
    <button class="collapsible">11.3.3.1 distinguish between laws of Boolean logic 11.3.3.2 simplify logical expressions using the laws of Boolean logic      <br>        11.3.3.3 build truth tables AND, OR, NOT, NAND, NOR, XOR </button>
<div class="content">
  <p><b>11.3.3.1 distinguish between laws of Boolean logic<br>11.3.3.2 simplify logical expressions using the laws of Boolean logic</b></p>
     <table>
  <thead>
    <tr>
      <th >Laws	 </th>
        <th>AND</th>
        <th> OR</th>
     
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Identity</td>
     <td>	A∧1=A</td>
         <td>	A∨0=A</td>
      
    </tr>
      <tr>
      <td> Domination	</td>
      <td>A∧0=0</td>
          <td>A∨1=1</td>
    </tr>
      <tr>
      <td>Idempotent	</td>
      <td>A∧A=A</td>
             <td>A∨A=A</td>
    </tr>
      <tr>
      <td> Complement		</td>
      <td>A∧¬A=0</td>
             <td> A∨¬A=1	</td>
    </tr>
     
      <tr>
      <td> Double Complement	</td>
      <td>.</td>
             <td> ¬(¬A)=A	</td>
    </tr>
      
       <tr>
      <td> De Morgan's Theorems		</td>
      <td>¬(A∧B)=¬A∨¬B</td>
             <td>¬(A∨B)=¬A∧¬B	</td>
    </tr>
       <tr>
      <td>Distributive	</td>
      <td>A∧(B∨C)=(A∧B)∨(A∧C)</td>
             <td>A∨(B∧C)=(A∨B)∧(A∨C)	</td>
    </tr>
       <tr>
      <td> Absorption 	</td>
      <td>A∧(A∨B)=A</td>
             <td> A∨(A∧B)=A	</td>
    </tr>
  </tbody>
</table>
      
      
   
   <p> <b> 11.3.3.3 build truth tables AND, OR, NOT, NAND, NOR, XOR </b>
    <br>1. AND (A ∧ B)
    </p>
    <table>
  <thead>
    <tr>
      <th >A	 </th>
        <th>B</th>
        <th> A ∧ B</th>
     
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
     <td>	0</td>
         <td>	0</td>
      
    </tr>
      <tr>
      <td> 0	</td>
      <td>1</td>
          <td>0</td>
    </tr>
      <tr>
      <td>1	</td>
      <td>0</td>
             <td>0</td>
    </tr>
      <tr>
      <td> 1		</td>
      <td>1</td>
             <td> 1	</td>
    </tr>
     
     
      
  </tbody>
</table>
   
    <p>OR (A ∨ B)</p>
    <table>
  <thead>
    <tr>
      <th >A	 </th>
        <th>B</th>
        <th> A ∨ B</th>
     
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
     <td>	0</td>
         <td>	0</td>
      
    </tr>
      <tr>
      <td> 0	</td>
      <td>1</td>
          <td>1</td>
    </tr>
      <tr>
      <td>1	</td>
      <td>0</td>
             <td>1</td>
    </tr>
      <tr>
      <td> 1		</td>
      <td>1</td>
             <td> 1	</td>
    </tr>
     
     
      
  </tbody>
</table>
    
    <p>NOT (¬A)</p>
      <table>
  <thead>
    <tr>
      <th >A	 </th>
        <th> 	¬A</th>
     
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
     <td>	1</td>
        
      
    </tr>
      <tr>
      <td> 1	</td>
      <td>0</td>
          
    </tr>
      
  </tbody>
</table>
    
    <p>NAND (A ↑ B)</p>
     <table>
  <thead>
    <tr>
      <th >A	 </th>
        <th>B</th>
        <th> A ↑ B</th>
     
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
     <td>	0</td>
         <td>	1</td>
      
    </tr>
      <tr>
      <td> 0	</td>
      <td>1</td>
          <td>1</td>
    </tr>
      <tr>
      <td>1	</td>
      <td>0</td>
             <td>1</td>
    </tr>
      <tr>
      <td> 1		</td>
      <td>1</td>
             <td> 0	</td>
    </tr>
     
     
      
  </tbody>
</table>
    <p>NOR (A ↓ B)</p>
     <table>
  <thead>
    <tr>
      <th >A	 </th>
        <th>B</th>
        <th> A ↓ B</th>
     
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
     <td>	0</td>
         <td>	1</td>
      
    </tr>
      <tr>
      <td> 0	</td>
      <td>1</td>
          <td>0</td>
    </tr>
      <tr>
      <td>1	</td>
      <td>0</td>
             <td>0</td>
    </tr>
      <tr>
      <td> 1		</td>
      <td>1</td>
             <td> 0	</td>
    </tr>
     
     
      
  </tbody>
</table>
    <p> XOR (A ⊕ B)</p>
   <table>
  <thead>
    <tr>
      <th >A	 </th>
        <th>B</th>
        <th> A ⊕ B</th>
     
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
     <td>	0</td>
         <td>	0</td>
      
    </tr>
      <tr>
      <td> 0	</td>
      <td>1</td>
          <td>1</td>
    </tr>
      <tr>
      <td>1	</td>
      <td>0</td>
             <td>1</td>
    </tr>
      <tr>
      <td> 1		</td>
      <td>1</td>
             <td> 0</td>
    </tr>
     
     
      
  </tbody>
</table>
</div>
     <button class="collapsible">11.5.1.1 distinguish between generations of programming languages <br>11.5.1.2 classify programming languages into low-level and high level <br>11.5.1.3 analyze a simple program written in the language of assembler  </button>
<div class="content">
    <p><b>11.5.1.1 distinguish between generations of programming languages<br></b>Programming languages are categorized into generations based on their level of abstraction and the time they were developed.</p> 
    <table>
  <thead>
    <tr>
      <th ><b></b>	 </th>
       
     
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Generation</td>
           <td>Description</td>
     <td>	Characteristics</td>
         <td>	Example</td>
         
      
    </tr>
      <tr>
      <td> First Generation (1GL) - Machine Language	</td>
      <td>The lowest level of programming languages, consisting of binary code (0s and 1s) that the computer's hardware can directly execute.</td>
          <td>Highly efficient but difficult for humans to read or write. Each instruction corresponds directly to a specific operation on the hardware.</td>
           <td> Binary code for operations, like 10101100 (an instruction to perform an operation).</td>
    </tr>
      <tr>
      <td>Second Generation (2GL) - Assembly Language	</td>
      <td>A step above machine language, using symbolic representations (mnemonics) instead of binary code. Each assembly language instruction corresponds to a machine language instruction.</td>
             <td> More readable than machine language but still hardware-specific. Requires an assembler to convert code into machine language.</td>
           <td>Instructions like MOV A, B (move data from register B to register A).</td>
    </tr>
      <tr>
      <td> Third Generation (3GL) - High-Level Languages		</td>
      <td>These languages provide a greater level of abstraction from the hardware, allowing programmers to write code using syntax closer to human languages.</td>
             <td> Easier to read and write, portable across different platforms, and often feature strong abstraction mechanisms. Requires a compiler or interpreter to convert to machine code.</td>
           <td>Languages like C, C++, Java, and Python.</td>
    </tr>
       <tr>
      <td>Fourth Generation (4GL)	</td>
      <td>Designed to be more user-friendly and to reduce the complexity of programming, often used for database access and reporting.</td>
             <td>Focus on problem-solving, less emphasis on algorithmic detail, and may include natural language elements.</td>
           <td>SQL (Structured Query Language) for database queries.</td>
    </tr>
       <tr>
      <td>Fifth Generation (5GL)	</td>
      <td>The most advanced generation of programming languages, focused on solving problems using constraints rather than explicit programming.</td>
             <td>Often associated with artificial intelligence and knowledge-based systems. Programmers specify what the program should accomplish rather than how to achieve it.</td>
           <td>Prolog, a logic programming language used in AI applications.</td>
    </tr>
     
     
      
  </tbody>
    </table> 
    <p><b>11.5.1.2 classify programming languages into low-level and high level<br></b><b>
    <br>Low-Level Languages:</b>

<br>Definition: Languages that provide little or no abstraction from a computer's instruction set architecture. They are closely related to machine language and hardware.
<br>Types:
<br><b>Machine Language:</b> Binary code understood directly by the computer’s CPU.
<br><b>Assembly Language:</b> Uses mnemonics and symbols but still corresponds closely to machine instructions.
<br>Characteristics:
<br>1.More control over hardware resources.
<br>2.Faster execution times due to close proximity to machine code.
<br>3.Difficult to read and maintain, requiring detailed knowledge of hardware.
<br><br><b>High-Level Languages:</b>

<br>Definition: Languages that provide significant abstraction from machine language, allowing programmers to write instructions in a more human-readable format.
<br>Examples:<b> Languages such as Python, Java, C++, and Ruby.</b>
<br>Characteristics:
<br>1.Easier to learn and use, with more natural syntax.
<br>2.Less control over hardware, which may lead to less efficient execution compared to low-level languages.
<br>3.More portable across different systems due to abstraction.
    </p>
    <p><b>11.5.1.3 analyze a simple program written in the language of assembler <br></b></p>
     <table>
  <thead>
    <tr>
      <th ><b></b>	 </th>
       
     
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Instruction		</td>
           <td>Opcode</td>
     <td>	Description</td>
         
      
    </tr>
      <tr>
      <td> INP		</td>
      <td>901</td>
          <td>Input a value from the user.</td>
         
    </tr>
      <tr>
      <td>OUT		</td>
      <td>902</td>
             <td>Output a value to the user.	</td>
          
    </tr>
      <tr>
      <td>ADD		</td>
      <td>1XX</td>
             <td>Add a value from memory location XX to the accumulator.</td>
          
    </tr>
       <tr>
      <td>SUB			</td>
      <td>2XX</td>
             <td>Subtract a value from memory location XX from the accumulator.</td>
       </tr>  
       <tr>
      <td>STA	</td>
      <td>3XX	</td>
             <td>	Store the value in the accumulator to memory location XX.</td>
           
    </tr>
       <tr>
      <td>LDA	</td>
      <td>5XX	</td>
             <td>			Load a value from memory location XX into the accumulator.</td>
           
    </tr>
       <tr>
      <td>HLT	</td>
      <td>000	</td>
             <td>			Halt the program.</td>
           
    </tr>
      
            </tbody>
        </table>
    <h3>Example code</h3><p>
   <br><b> 00 INP    </b>    // Take the first input from the user and store it in the accumulator.
<br><b>01 STA 99  </b>     // Store the value from the accumulator to memory location 99.
<br><b>02 INP     </b>     // Take the second input from the user and store it in the accumulator.
<br><b>03 ADD 99 </b>      // Add the value from memory location 99 to the accumulator.
<br><b>04 OUT   </b>       // Output the result.
<br><b>05 HLT    </b>      // Halt the program.
<br><b>99 DAT 0  </b>      // Initialize memory location 99 to store the first input.
</p>
</div>
     <button class="collapsible">11.5.1.5 analyze advantages and disadvantages of high-level languages <br>11.5.1.6 analyze advantages and disadvantages of low-level languages </button>
<div class="content">
  <p><b>11.5.1.5 analyze advantages and disadvantages of high-level languages</b>
      <br><b><i>Advantages of High-Level Languages</i></b>
<br><b>Ease of Use: </b>The syntax and structure are closer to human language, making HLLs easier to learn and use, which reduces development time.
<br><b>Portability: </b>HLLs are generally platform-independent, meaning code written in these languages can often run on different hardware and operating systems with minimal modifications.
<br><b>Error Reduction:</b> HLLs have features like error handling, debugging tools, and libraries that help catch and manage errors more efficiently.
<br><b>Standardization and Libraries: </b>Extensive libraries and frameworks available in HLLs simplify complex tasks like data manipulation, graphics, and networking, reducing the need for repetitive coding.
      
 <br><b><i>Disadvantages of High-Level Languages</i></b>
<br><b>Lower Performance:</b> HLLs often result in slower execution times than low-level languages due to the higher level of abstraction and the need for interpretation or compilation.
<br><b>Less Control Over Hardware: </b>HLLs limit access to hardware, which can be restrictive in situations that require direct hardware control (e.g., embedded systems).
<br><b>Increased Resource Usage:</b> High-level languages generally require more memory and processing power due to the abstraction layers, which can be inefficient on limited-resource devices.

 <br><br><b>11.5.1.6 analyze advantages and disadvantages of low-level languages  </b> 
    
   <br><b><i> Advantages of Low-Level Languages</i></b>
<br><b>High Performance: </b>Low-level languages are fast and efficient because they execute instructions directly on the hardware without requiring translation through a compiler or interpreter.
<br><b>Direct Hardware Access:</b> LLLs allow precise control over hardware, which is essential for tasks requiring direct memory manipulation, peripheral control, or real-time computing.
<br><b>Memory Efficiency: </b>Programs written in LLLs use minimal memory and processing power, making them ideal for resource-constrained environments (e.g., embedded systems).
<br><b>Optimization:</b> Programmers can fine-tune LLL code for specific hardware, optimizing programs for speed and efficiency in ways not possible with HLLs.
      
 <br><b><i>Disadvantages of Low-Level Languages</i></b>
<br><b>Complexity and Difficulty: </b>LLLs have a steep learning curve and are challenging to read, write, and debug due to their close resemblance to machine code.
<br><b>Lack of Portability:</b> Programs in LLLs are highly hardware-specific and often need to be rewritten for different types of hardware or operating systems.
<br><b>Time-Consuming Development:</b> Writing programs in LLLs is slow and labor-intensive since each line of code corresponds closely to an individual machine instruction.
<br><b>Error-Prone: </b>The detailed nature of LLLs makes them prone to coding errors, which are difficult to debug without high-level abstractions or error-handling mechanisms.</p>
</div>
    
     <button class="collapsible">11.5.1.7 analyze advantages and disadvantages of compilers <br>11.5.1.8 analyze advantages and disadvantages of interpreters </button>
<div class="content">
  <p>
   <p><b>   11.5.1.7 analyze advantages and disadvantages of compilers  </b> 
      
 <br><b><i>     Advantages of Compilers</i></b>
<br><b>High Execution Speed:</b> Compiled code runs faster because the entire program is translated into machine code at once. There’s no need for further translation during runtime.
<br><b>Error Detection Before Execution:</b> Compilers check for syntax and semantic errors before producing an executable, helping programmers to identify and fix errors before the program runs.
<br><b>Security:</b> Compiled programs are typically more secure, as the source code is not directly available to the end-user. This reduces the risk of unauthorized code modifications.
<br><b>Optimizations: </b>Compilers can optimize the code for performance, improving speed and efficiency. This can be especially helpful for resource-intensive applications.
      
      
<br><b><i>Disadvantages of Compilers</i></b>
<br><b>Longer Compilation Time:</b> Compiling large programs can be time-consuming, and any change to the code requires a full recompilation, which can slow down development.
<br><b>Lack of Flexibility:</b> Since the entire program is compiled before execution, making runtime decisions or dynamic code modifications is difficult.
<br><b>Platform Dependency: </b>Compiled code is usually platform-specific, meaning different versions of the executable might be required for different operating systems or hardware configurations.
<br><b>Debugging Limitations: </b>Since compiled code runs independently of the source code, debugging can be challenging, and specialized debugging tools are often required.
    
<p><b>    11.5.1.8 analyze advantages and disadvantages of interpreters  </b> 
      
   <br><b><i> Advantages of Interpreters</i></b>
<br><b>Immediate Execution and Testing:</b> Code can be executed line by line, which is beneficial for testing and debugging as it allows for quick iterations and immediate feedback on code changes.
<br><b>Platform Independence:</b> Since interpreters translate code at runtime, the same code can often run on multiple platforms as long as an appropriate interpreter is available.
<br><b>Greater Flexibility: </b>Interpreters allow for dynamic execution and modification, which is useful in applications requiring runtime decisions, such as scripting or interactive applications.
<br><b>Ideal for Rapid Development:</b> Interpreters facilitate rapid prototyping and development because there’s no need to compile the entire program before running it.
      
      
<br><b><i>Disadvantages of Interpreters</i></b>
<br><b>Slower Execution:</b> Since each line of code is translated during execution, interpreted programs generally run slower than compiled programs, which can be a drawback for performance-intensive applications.
<br><b>Higher Resource Usage: </b>Interpreters require the source code to be present during execution, which can consume more memory and processing power, especially for large programs.
<br><b>Limited Security: </b>The source code is available in an interpreted program, making it more susceptible to unauthorized access or modification compared to compiled code.
<br><b>No Code Optimization: </b>Interpreters typically do not optimize the code, which can lead to inefficient execution compared to compiled code where optimizations are applied.</p>
</div>
    
    <button class="collapsible">11.2.1.1 Explain the Life Cycle Stages Used in Solving Problems <br>11.2.1.2 analyses the advantages and disadvantages of cyclical, waterfall and spiral models </button>
<div class="content">
  
   <p><b> 11.2.1.1 Explain the Life Cycle Stages Used in Solving Problems   </b> 
      
<b>Problem-Solving Life Cycle Stages:</b><br><br>
    <br> 1. <b>Analysis:</b> Identify and analyze the problem in detail, gathering requirements.
    <br> 2. <b>Design:</b> Develop a plan or model for the solution.
    <br> 3. <b>Implementation:</b> Write code and develop the system based on the design.
    <br> 4. <b>Testing:</b> Ensure that the solution meets the requirements without errors.
    <br> 5. <b>Evaluation:</b> Assess the effectiveness and efficiency of the solution.
    <br> 6. <b>Maintenance:</b> Update and improve the system as necessary.
<br><br><br>
      
<p><b>   11.2.1.2 analyses the advantages and disadvantages of cyclical, waterfall and spiral models  </b> 
      <br><br>
  <b>Cyclical Model</b> <br>
    <br> <i>Advantages:</i> Allows iterative improvement, adaptable to changes.
    <br> <i>Disadvantages:</i>Can be time-consuming and lack clear structure.
  </p><br>
  <p><b>Waterfall Model</b> <br>
    <br><i>Advantages:</i> Simple and straightforward; stages are well-defined.
    <br> <i>Disadvantages:</i> Limited flexibility for changes once a stage is completed.
  </p><br>
  <p><b>Spiral Model</b><br>
    <br> <i>Advantages:</i> High flexibility; incorporates risk analysis.
    <br> <i>Disadvantages:</i>  Expensive and complex, requires skilled project management.
 
      
</p>
</div>
    
     <button class="collapsible">11.2.1.3 describe data collection methods <br> 11.2.1.4 compare different data collection techniques  </button>
<div class="content">
  <br>
   <p><b>11.2.1.3 describe data collection methods </b> <br>
      
<b>Data Collection Methods:</b> 
    <br> 1. <b>Surveys:</b> Collect data via structured questions.
    <br> 2. <b>Interviews:</b> Gather detailed responses through direct interaction.
    <br> 3. <b>Observations:</b> Record data based on observation of behavior.
    <br> 4. <b>Document Analysis:</b> Analyze existing documents for relevant data.
    <br>
    <br>

      
<p><b>  11.2.1.4 compare different data collection techniques  </b> 
      <br><br>
     <b>Data Collection Techniques Comparison:</b></p>
  <table border="1" cellpadding="10">
    <thead>
      <tr>
        <th>Technique</th>
        <th>Advantages</th>
        <th>Disadvantages</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Surveys</td>
        <td>Efficient for collecting data from large groups</td>
        <td>May lack depth and personalization in responses</td>
      </tr>
      <tr>
        <td>Interviews</td>
        <td>Provides in-depth information and insight</td>
        <td>Time-consuming and may introduce interviewer bias</td>
      </tr>
      <tr>
        <td>Observations</td>
        <td>Captures real-time, contextual data</td>
        <td>Subjective, may lack participant input or reasoning</td>
      </tr>
      <tr>
        <td>Document Analysis</td>
        <td>Useful for historical and secondary data</td>
        <td>May lack current context and user interpretation</td>
      </tr>
    </tbody>
  </table>

</div>
      
    
    <button class="collapsible">11.2.1.5 compare alternative solutions to a problem in order to choose the most effective algorithm  <br>11.2.1.8 develop a system requirement based on collected information  </button>
<div class="content">
  
    <p><b>11.2.1.5 compare alternative solutions to a problem in order to choose the most effective algorithm   </b> </p>
      <br>
 <p><b>Choosing the Most Effective Algorithm:</b>
    <br> Compare solutions based on:
    <br> <b>Efficiency:</b> Speed and resource usage.
    <br> <b>Scalability:</b> Ability to handle larger inputs.
    <br> <b>Complexity:</b> Ease of understanding and implementing.
    <br> <b>Reliability:</b> Consistency of producing accurate results.
  </p>
      <br><br>
<p><b>  11.2.1.8 develop a system requirement based on collected information </b> 
      <br><br>
    <b>Developing System Requirements:</b>
    <br> Based on data collection, outline:
    <br> <b>Functional Requirements:</b> Specific features or tasks the system must perform.
    <br> <b>Non-functional Requirements:</b> Constraints on the system, such as speed or usability.
    <br> <b>User Requirements:</b> Expectations and goals of the end-users.
  
</p>
</div>
    
  
    
   
  <button class="collapsible">11.2.1.6 use data flow diagrams (DFD) to input, process, store and output data in computing systems <br>11.2.1.7 use flow charts to input, process, store and output data in computing systems </button>
  <div class="content">
    <p><b>Data Flow Diagrams (DFD) Symbols</b> shows how data moves around a system.   It shows how data is captured, processed, stored and distributed within a system. A data flow diagram is a logical model of a system. 
<br><br>
      A data flow diagram uses four basic symbols to form a picture of a logical system.</p>
    <table border="1" cellpadding="10">
      <thead>
        <tr>
          <th>Symbol</th>
          <th>Description</th>
          <th>Image</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Process</td>
          <td>Represents a process that transforms data inputs into outputs</td>
          <td><img src="images/process_symbol.png" alt="Process Symbol" width="100"></td>
        </tr>
        <tr>
          <td>Data Store</td>
          <td>Represents where data is stored within the system</td>
          <td><img src="images/data_store_symbol.png" alt="Data Store Symbol" width="100"></td>
        </tr>
        <tr>
          <td>Data Flow</td>
          <td>Indicates the direction of data movement in the system</td>
          <td><img src="images/data_flow_symbol.png" alt="Data Flow Symbol" width="100"></td>
        </tr>
        <tr>
          <td>External Entity</td>
          <td>Represents external sources or destinations of data</td>
          <td><img src="images/external_entity_symbol..png" alt="External Entity Symbol" width="100"></td>
        </tr>
      </tbody>
    </table>
      <p style="font-size: 20px;"><b> Example task</b></p><br>
  <p>  <br>  A supermarket’s Point Of Sale (POS) system operates as follows:
<br>• Product data (ProductID, Price, Product Description) are stored in the database, Product Database.
<br>• A barcode is present on each shopping basket item.
<br>• A shop assistant scans each shopping basket item with a barcode scanner.
<br>• A process, Calculate Bill, generates a Bill which is presented to the customer.
      <br>• The bill is itemised with Product Description, Price for each item sold.</p>
 <p style="font-size: 20px;"><b> Answer</b></p><br>
    
<img src="images/dfd.png" alt="External Entity Symbol" >
      
        <br><br>
    <p><b>11.2.1.7 use flow charts to input, process, store and output data in computing systems</b></p><br>
      <p>A flowchart is a type of diagram that represents a workflow or process. A flowchart can also be defined as a diagrammatic representation of an algorithm, a step-by-step approach to solving a task.</p><br>
    <table border="1" cellpadding="10">
      <thead>
        <tr>
          <th>Symbol</th>
          <th>Description</th>
          <th>Image</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Start/End</td>
          <td>Marks the beginning or end of a flowchart process</td>
          <td><img src="images/start_end_symbol.png" alt="Start/End Symbol" width="100"></td>
        </tr>
        <tr>
          <td>Process</td>
          <td>Represents a task or action in the process flow</td>
          <td><img src="images/process_symbol_flowchart.png" alt="Process Symbol" width="100"></td>
        </tr>
        <tr>
          <td>Decision</td>
          <td>Indicates a point where a decision is required</td>
          <td><img src="images/decision_symbol.png" alt="Decision Symbol" width="100"></td>
        </tr>
        <tr>
          <td>Input/Output</td>
          <td>Represents an input or output in the flow of the process</td>
          <td><img src="images/input_output_symbol.png" alt="Input/Output Symbol" width="100"></td>
        </tr>
      </tbody>
    </table><br>
      <p style="font-size: 20px;"><b> Example</b></p><br>
    
<img src="images/flowchart.png" alt="External Entity Symbol" >
  </div>

<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.maxHeight){
      content.style.maxHeight = null;
    } else {
      content.style.maxHeight = content.scrollHeight + "px";
    } 
  });
}
</script>
    
    </section>
         

    
    </body>
</html>

